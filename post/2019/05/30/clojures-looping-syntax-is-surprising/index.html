<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Clojure&#39;s Looping Syntax is Surprising | Azrea Amis</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css><link rel=stylesheet href=/css/bundle.css></head><body><nav><ul class=menu><li><a href=/>Home</a></li><li><a href=/posts/>Posts</a></li><li><a href=/tags/>Tags</a></li><li><a href=/projects/>Projects</a></li><li><a href=/pictures/>Pictures</a></li><li><a href=/downloads/resume.pdf>Resume</a></li></ul><hr></nav><div class=article-meta><h1><span class=title>Clojure&#39;s Looping Syntax is Surprising</span></h1><h2 class=date>2019/05/30</h2></div><main><p>They aren&rsquo;t <em>super</em> popular, but Clojure has a rich set of high level looping
macros. You have <code>for</code> for list comprehensions, <code>doseq</code> for imperative looping
over sequences, <code>dotimes</code> for an even simpler integer loop, <code>while</code> for raw
predicate looping, and <code>loop</code> for any kind of arbitrary recursion-style looping
you want to do. However, I&rsquo;m not a huge fan of the exact syntax some of these
macros use.</p><p>Let&rsquo;s talk about <code>let</code>, which looks like this:</p><div class=highlight><pre class=chroma><code class=language-Clojure data-lang=Clojure><span class=nv>=&gt;</span> <span class=p>(</span><span class=k>let </span><span class=p>[</span><span class=nv>x</span> <span class=mi>10</span>
         <span class=nv>y</span> <span class=ss>:asdf</span>
         <span class=nv>z</span> <span class=p>(</span><span class=nb>range </span><span class=mi>10</span><span class=p>)]</span>
     <span class=p>(</span><span class=nb>vector </span><span class=nv>x</span> <span class=nv>y</span> <span class=nv>z</span><span class=p>))</span>
<span class=p>[</span><span class=mi>10</span> <span class=ss>:asdf</span> <span class=p>(</span><span class=mi>0</span> <span class=mi>1</span> <span class=mi>2</span> <span class=mi>3</span> <span class=mi>4</span> <span class=mi>5</span> <span class=mi>6</span> <span class=mi>7</span> <span class=mi>8</span> <span class=mi>9</span><span class=p>)]</span></code></pre></div><p><code>let</code> binds the values to names in order, then executes the body in that lexical
context. Although they&rsquo;re bound in a particular order, they get bound once, then
the body is executed once, as you&rsquo;d expect.</p><p>So, how does <code>for</code> work? Here&rsquo;s a basic example:</p><div class=highlight><pre class=chroma><code class=language-Clojure data-lang=Clojure><span class=nv>=&gt;</span> <span class=p>(</span><span class=nb>for </span><span class=p>[</span><span class=nv>x</span> <span class=p>(</span><span class=nb>range </span><span class=mi>5</span><span class=p>)]</span>
     <span class=nv>x</span><span class=p>)</span>
<span class=p>(</span><span class=mi>0</span> <span class=mi>1</span> <span class=mi>2</span> <span class=mi>3</span> <span class=mi>4</span><span class=p>)</span></code></pre></div><p>As a &ldquo;list comprehension&rdquo;, <code>for</code> binds the values in sequence, then constructs a
list based on the value of the body. <code>x</code> gets re-bound to the next item in the
sequence (which is <code>(range 5)</code> here) and the body gets re-executed for as long
as the sequence has items remaining.</p><p>So imagine you&rsquo;re learning Clojure. Based on how <code>let</code> binds its values, how
would you expect this to work:</p><div class=highlight><pre class=chroma><code class=language-Clojure data-lang=Clojure><span class=nv>=&gt;</span> <span class=p>(</span><span class=nb>for </span><span class=p>[</span><span class=nv>x</span> <span class=p>(</span><span class=nb>range </span><span class=mi>5</span><span class=p>)</span>
         <span class=nv>y</span> <span class=p>(</span><span class=nb>range </span><span class=mi>5</span><span class=p>)]</span>
     <span class=p>[</span><span class=nv>x</span> <span class=nv>y</span><span class=p>])</span></code></pre></div><p>Would you expect it to work like this?</p><div class=highlight><pre class=chroma><code class=language-Clojure data-lang=Clojure><span class=p>([</span><span class=mi>0</span> <span class=mi>0</span><span class=p>]</span> <span class=p>[</span><span class=mi>1</span> <span class=mi>1</span><span class=p>]</span> <span class=p>[</span><span class=mi>2</span> <span class=mi>2</span><span class=p>]</span> <span class=p>[</span><span class=mi>3</span> <span class=mi>3</span><span class=p>]</span> <span class=p>[</span><span class=mi>4</span> <span class=mi>4</span><span class=p>])</span></code></pre></div><p>The 2 sequences get iterated over together, in lock step. This is not how it
works, however:</p><div class=highlight><pre class=chroma><code class=language-Clojure data-lang=Clojure><span class=p>([</span><span class=mi>0</span> <span class=mi>0</span><span class=p>]</span> <span class=p>[</span><span class=mi>0</span> <span class=mi>1</span><span class=p>]</span> <span class=p>[</span><span class=mi>0</span> <span class=mi>2</span><span class=p>]</span> <span class=p>[</span><span class=mi>0</span> <span class=mi>3</span><span class=p>]</span> <span class=p>[</span><span class=mi>0</span> <span class=mi>4</span><span class=p>]</span>
 <span class=p>[</span><span class=mi>1</span> <span class=mi>0</span><span class=p>]</span> <span class=p>[</span><span class=mi>1</span> <span class=mi>1</span><span class=p>]</span> <span class=p>[</span><span class=mi>1</span> <span class=mi>2</span><span class=p>]</span> <span class=p>[</span><span class=mi>1</span> <span class=mi>3</span><span class=p>]</span> <span class=p>[</span><span class=mi>1</span> <span class=mi>4</span><span class=p>]</span>
 <span class=p>[</span><span class=mi>2</span> <span class=mi>0</span><span class=p>]</span> <span class=p>[</span><span class=mi>2</span> <span class=mi>1</span><span class=p>]</span> <span class=p>[</span><span class=mi>2</span> <span class=mi>2</span><span class=p>]</span> <span class=p>[</span><span class=mi>2</span> <span class=mi>3</span><span class=p>]</span> <span class=p>[</span><span class=mi>2</span> <span class=mi>4</span><span class=p>]</span>
 <span class=p>[</span><span class=mi>3</span> <span class=mi>0</span><span class=p>]</span> <span class=p>[</span><span class=mi>3</span> <span class=mi>1</span><span class=p>]</span> <span class=p>[</span><span class=mi>3</span> <span class=mi>2</span><span class=p>]</span> <span class=p>[</span><span class=mi>3</span> <span class=mi>3</span><span class=p>]</span> <span class=p>[</span><span class=mi>3</span> <span class=mi>4</span><span class=p>]</span>
 <span class=p>[</span><span class=mi>4</span> <span class=mi>0</span><span class=p>]</span> <span class=p>[</span><span class=mi>4</span> <span class=mi>1</span><span class=p>]</span> <span class=p>[</span><span class=mi>4</span> <span class=mi>2</span><span class=p>]</span> <span class=p>[</span><span class=mi>4</span> <span class=mi>3</span><span class=p>]</span> <span class=p>[</span><span class=mi>4</span> <span class=mi>4</span><span class=p>])</span></code></pre></div><p>It iterates over the entirety of the second sequence <em>for each value in the
first sequence</em>, and this generalizes over any number of sequences. <code>doseq</code>
works the same way, but it doesn&rsquo;t construct a list, and it&rsquo;s eager (where <code>for</code>
is lazy).</p><p>So what would you do if you <em>did</em> want to iterate over 2 sequences together?</p><div class=highlight><pre class=chroma><code class=language-Clojure data-lang=Clojure><span class=nv>=&gt;</span> <span class=p>(</span><span class=nb>for </span><span class=p>[[</span><span class=nv>x</span> <span class=nv>y</span><span class=p>]</span> <span class=p>(</span><span class=nb>map vector </span><span class=p>(</span><span class=nb>range </span><span class=mi>5</span><span class=p>)</span>
                           <span class=p>(</span><span class=nb>range </span><span class=mi>5</span><span class=p>))]</span>
     <span class=p>[</span><span class=nv>x</span> <span class=nv>y</span><span class=p>])</span>
<span class=p>([</span><span class=mi>0</span> <span class=mi>0</span><span class=p>]</span> <span class=p>[</span><span class=mi>1</span> <span class=mi>1</span><span class=p>]</span> <span class=p>[</span><span class=mi>2</span> <span class=mi>2</span><span class=p>]</span> <span class=p>[</span><span class=mi>3</span> <span class=mi>3</span><span class=p>]</span> <span class=p>[</span><span class=mi>4</span> <span class=mi>4</span><span class=p>])</span></code></pre></div><p>This uses <code>map</code> to construct series of intermediate vectors (because <code>map</code> deals
with multiple sequences by mapping over them together), then uses the binding
syntax to deconstruct the vector into <code>x</code> and <code>y</code> to keep the variable names the
same as the above examples, then returns the vector of <code>[x y]</code> we&rsquo;re actually
looking for. And what if you didn&rsquo;t want to make the intermediate vectors? Well, then you&rsquo;re back to using <code>loop</code>:</p><div class=highlight><pre class=chroma><code class=language-Clojure data-lang=Clojure><span class=nv>=&gt;</span> <span class=p>(</span><span class=k>loop </span><span class=p>[</span><span class=nv>x</span> <span class=p>(</span><span class=nb>range </span><span class=mi>5</span><span class=p>)</span>
          <span class=nv>y</span> <span class=p>(</span><span class=nb>range </span><span class=mi>5</span><span class=p>)]</span>
     <span class=p>(</span><span class=nb>when </span><span class=p>(</span><span class=nb>not </span><span class=p>(</span><span class=nf>empty?</span> <span class=nv>x</span><span class=p>))</span>
       <span class=p>(</span><span class=nb>println </span><span class=p>[(</span><span class=nb>first </span><span class=nv>x</span><span class=p>)</span> <span class=p>(</span><span class=nb>first </span><span class=nv>y</span><span class=p>)])</span>
       <span class=p>(</span><span class=nf>recur</span> <span class=p>(</span><span class=nb>rest </span><span class=nv>x</span><span class=p>)</span> <span class=p>(</span><span class=nb>rest </span><span class=nv>y</span><span class=p>))))</span>
<span class=p>[</span><span class=mi>0</span> <span class=mi>0</span><span class=p>]</span>
<span class=p>[</span><span class=mi>1</span> <span class=mi>1</span><span class=p>]</span>
<span class=p>[</span><span class=mi>2</span> <span class=mi>2</span><span class=p>]</span>
<span class=p>[</span><span class=mi>3</span> <span class=mi>3</span><span class=p>]</span>
<span class=p>[</span><span class=mi>4</span> <span class=mi>4</span><span class=p>]</span>
<span class=nv>nil</span></code></pre></div><p>This binds <code>x</code> and <code>y</code> to the range sequences initially (and they get rebound
together each loop), prints their first element, then recurses on the rest of
both. When <code>x</code> is empty it returns nil, and it doesn&rsquo;t particularly deal with
sequences of unequal length.</p><p>This is pretty inconvenient to do with any regularity. <code>loop</code> is really powerful
and <em>very</em> performant, but you have to do almost everything by hand.</p><p>For me, at least, this iteration pattern violates the principal of least
surprise. I learned Racket before Clojure, and this is exactly how Racket works.</p><div class=highlight><pre class=chroma><code class=language-Racket data-lang=Racket><span class=nb>&gt;</span> <span class=p>(</span><span class=k>for/list</span> <span class=p>[[</span><span class=n>x</span> <span class=p>(</span><span class=nb>range</span> <span class=mi>5</span><span class=p>)]</span>
             <span class=p>[</span><span class=n>y</span> <span class=p>(</span><span class=nb>range</span> <span class=mi>5</span><span class=p>)]]</span>
    <span class=p>(</span><span class=nb>list</span> <span class=n>x</span> <span class=n>y</span><span class=p>))</span>
<span class=o>&#39;</span><span class=p>((</span><span class=mi>0</span> <span class=mi>0</span><span class=p>)</span> <span class=p>(</span><span class=mi>1</span> <span class=mi>1</span><span class=p>)</span> <span class=p>(</span><span class=mi>2</span> <span class=mi>2</span><span class=p>)</span> <span class=p>(</span><span class=mi>3</span> <span class=mi>3</span><span class=p>)</span> <span class=p>(</span><span class=mi>4</span> <span class=mi>4</span><span class=p>))</span></code></pre></div><p>I really honestly expected, based on how <code>let</code> works and how Racket works, that
<code>for</code> would loop together. The worst part is that, for newer users, <code>(map
vector)</code> is not particularly intuitive, and if you want to iterate like that,
it&rsquo;s much more natural to nest your loops <em>syntactically</em> rather than implicitly:</p><div class=highlight><pre class=chroma><code class=language-Clojure data-lang=Clojure><span class=nv>=&gt;</span> <span class=p>(</span><span class=nb>for </span><span class=p>[</span><span class=nv>x</span> <span class=p>(</span><span class=nb>range </span><span class=mi>5</span><span class=p>)]</span>
     <span class=p>(</span><span class=nb>for </span><span class=p>[</span><span class=nv>y</span> <span class=p>(</span><span class=nb>range </span><span class=mi>5</span><span class=p>)]</span>
       <span class=p>[</span><span class=nv>x</span> <span class=nv>y</span><span class=p>]))</span>
<span class=p>(([</span><span class=mi>0</span> <span class=mi>0</span><span class=p>]</span> <span class=p>[</span><span class=mi>0</span> <span class=mi>1</span><span class=p>]</span> <span class=p>[</span><span class=mi>0</span> <span class=mi>2</span><span class=p>]</span> <span class=p>[</span><span class=mi>0</span> <span class=mi>3</span><span class=p>]</span> <span class=p>[</span><span class=mi>0</span> <span class=mi>4</span><span class=p>])</span>
 <span class=p>([</span><span class=mi>1</span> <span class=mi>0</span><span class=p>]</span> <span class=p>[</span><span class=mi>1</span> <span class=mi>1</span><span class=p>]</span> <span class=p>[</span><span class=mi>1</span> <span class=mi>2</span><span class=p>]</span> <span class=p>[</span><span class=mi>1</span> <span class=mi>3</span><span class=p>]</span> <span class=p>[</span><span class=mi>1</span> <span class=mi>4</span><span class=p>])</span>
 <span class=p>([</span><span class=mi>2</span> <span class=mi>0</span><span class=p>]</span> <span class=p>[</span><span class=mi>2</span> <span class=mi>1</span><span class=p>]</span> <span class=p>[</span><span class=mi>2</span> <span class=mi>2</span><span class=p>]</span> <span class=p>[</span><span class=mi>2</span> <span class=mi>3</span><span class=p>]</span> <span class=p>[</span><span class=mi>2</span> <span class=mi>4</span><span class=p>])</span>
 <span class=p>([</span><span class=mi>3</span> <span class=mi>0</span><span class=p>]</span> <span class=p>[</span><span class=mi>3</span> <span class=mi>1</span><span class=p>]</span> <span class=p>[</span><span class=mi>3</span> <span class=mi>2</span><span class=p>]</span> <span class=p>[</span><span class=mi>3</span> <span class=mi>3</span><span class=p>]</span> <span class=p>[</span><span class=mi>3</span> <span class=mi>4</span><span class=p>])</span>
 <span class=p>([</span><span class=mi>4</span> <span class=mi>0</span><span class=p>]</span> <span class=p>[</span><span class=mi>4</span> <span class=mi>1</span><span class=p>]</span> <span class=p>[</span><span class=mi>4</span> <span class=mi>2</span><span class=p>]</span> <span class=p>[</span><span class=mi>4</span> <span class=mi>3</span><span class=p>]</span> <span class=p>[</span><span class=mi>4</span> <span class=mi>4</span><span class=p>]))</span></code></pre></div><p>Nested for loops even handle predicates just fine:</p><div class=highlight><pre class=chroma><code class=language-Clojure data-lang=Clojure><span class=nv>=&gt;</span> <span class=p>(</span><span class=nb>for </span><span class=p>[</span><span class=nv>x</span> <span class=p>(</span><span class=nb>range </span><span class=mi>5</span><span class=p>)]</span>
     <span class=p>(</span><span class=nb>for </span><span class=p>[</span><span class=nv>y</span> <span class=p>(</span><span class=nb>range </span><span class=mi>5</span><span class=p>)</span>
           <span class=ss>:when</span> <span class=p>(</span><span class=nb>&lt; </span><span class=nv>x</span> <span class=nv>y</span><span class=p>)]</span>
       <span class=p>[</span><span class=nv>x</span> <span class=nv>y</span><span class=p>]))</span>
<span class=p>(([</span><span class=mi>0</span> <span class=mi>1</span><span class=p>]</span> <span class=p>[</span><span class=mi>0</span> <span class=mi>2</span><span class=p>]</span> <span class=p>[</span><span class=mi>0</span> <span class=mi>3</span><span class=p>]</span> <span class=p>[</span><span class=mi>0</span> <span class=mi>4</span><span class=p>])</span>
<span class=p>([</span><span class=mi>1</span> <span class=mi>2</span><span class=p>]</span> <span class=p>[</span><span class=mi>1</span> <span class=mi>3</span><span class=p>]</span> <span class=p>[</span><span class=mi>1</span> <span class=mi>4</span><span class=p>])</span>
<span class=p>([</span><span class=mi>2</span> <span class=mi>3</span><span class=p>]</span> <span class=p>[</span><span class=mi>2</span> <span class=mi>4</span><span class=p>])</span>
<span class=p>([</span><span class=mi>3</span> <span class=mi>4</span><span class=p>])</span>
<span class=p>())</span></code></pre></div><p>The astute among you will notice that this produces a different value, namely
that the inner loop produces sequences, which the outer loop put into another
sequence with no flatten, so this is a list of list of vectors instead of just a
list of vectors. This is a pretty normal problem for Clojurians to solve, so it
doesn&rsquo;t seem insurmountable. Additionally, a version of <code>for</code> that flattens or
appends bodies, and therefore produces the same value would also not be hard to
develop or understand. This pattern is flawlessly applicable to <code>doseq</code> use
cases, for example.<sup class=footnote-ref id=fnref:2><a href=#fn:2>1</a></sup> This is also exactly how non-lisp languages solve these
problems.</p><div class=highlight><pre class=chroma><code class=language-Rust data-lang=Rust><span class=k>for</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=mi>0</span><span class=p>..</span><span class=mi>5</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=mi>0</span><span class=p>..</span><span class=mi>5</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;{:?}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>vec</span><span class=o>!</span><span class=p>[</span><span class=n>x</span><span class=p>,</span><span class=w> </span><span class=n>y</span><span class=p>]);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=p>[</span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>]</span><span class=w>
</span><span class=w></span><span class=p>[</span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>]</span><span class=w>
</span><span class=w></span><span class=p>[</span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>]</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=p>...</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=p>[</span><span class=mi>4</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>]</span><span class=w>
</span><span class=w></span><span class=p>[</span><span class=mi>4</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>]</span><span class=w>
</span><span class=w></span><span class=p>[</span><span class=mi>4</span><span class=p>,</span><span class=w> </span><span class=mi>3</span><span class=p>]</span><span class=w>
</span><span class=w></span><span class=p>[</span><span class=mi>4</span><span class=p>,</span><span class=w> </span><span class=mi>4</span><span class=p>]</span><span class=w>
</span></code></pre></div><p>What about Common Lisp?</p><blockquote><p>LOOP provides what is essentially a special-purpose language just for writing
iteration constructs.<sup class=footnote-ref id=fnref:1><a href=#fn:1>2</a></sup></p></blockquote><p>Well alright then.</p><p>So that&rsquo;s my basic objection to this particular syntax choice in <code>for</code>. It
violates the principal set up by let, it&rsquo;s convenient for a scenario that isn&rsquo;t
particularly common and which has an easy solution (nested looping) while
forcing you to use obscure idioms for the other situation (synchronous looping).
You could argue that the synchronous looping has some pitfalls, such as &ldquo;what to
do when the sequences are of different length,&rdquo; and that perhaps the language
designers didn&rsquo;t want to force a core looping construct into either option, but
in fact, the designers already decided on how the language would operate in a
similar situation, <code>map</code>, which stops when the first sequence stops.</p><p>I&rsquo;m sure that Rich Hickey discussed this decision somewhere online, and
being Rich Hickey, he probably has good reasons, and it&rsquo;s too late now, but I
couldn&rsquo;t find it, so I&rsquo;m doing what any good netizen would do: complaining on my
blog.</p><div class=footnotes><hr><ol><li id=fn:2><p><code>dotimes</code>, which I mentioned earlier, allows exactly 1 binding per
expression, so the question of how to handle multiple bindings is
sidestepped.</p><a class=footnote-return href=#fnref:2><sup>[return]</sup></a></li><li id=fn:1><p><a href=http://www.gigamonkeys.com/book/loop-for-black-belts.html>LOOP for Black Belts</a> by Peter
Seibel, 2005. Accessed 2019.</p><a class=footnote-return href=#fnref:1><sup>[return]</sup></a></li></ol></div></main><hr><section><a class=tag href=/tags/clojure>clojure</a>
<a class=tag href=/tags/language>language</a></section><footer><div class="pride-strip pride-strip-position"></div><hr>&copy; <a href=http://atamis.me>Azrea Amis</a> &mdash; <a href=http://github.com/atamis>Github</a> &mdash; 2020</footer></body></html>