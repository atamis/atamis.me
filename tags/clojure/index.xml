<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>clojure on Azrea Amis</title><link>/tags/clojure/</link><description>Recent content in clojure on Azrea Amis</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.</copyright><lastBuildDate>Sun, 15 Dec 2019 23:01:08 +0100</lastBuildDate><atom:link href="/tags/clojure/index.xml" rel="self" type="application/rss+xml"/><item><title>"Interesting" Clojure Macro Interaction</title><link>/posts/2019-12-15-clojure-macro-interaction/</link><pubDate>Sun, 15 Dec 2019 23:01:08 +0100</pubDate><guid>/posts/2019-12-15-clojure-macro-interaction/</guid><description>Clojure&amp;rsquo;s macro system is a little tricky to work with (at least for me), but it&amp;rsquo;s also quite powerful. Being able to rewrite the languages AST at compile time is really cool, and the fact that Clojure&amp;rsquo;s syntax is just the data structures that normal Clojure code operate on makes writing macros a breeze (at least compared to, say, Rust or Javascript).
Clojure&amp;rsquo;s macro expansion works in dependable way: it keeps apply macros until there are no more macro calls in the code, then compiles the resulting code.</description></item><item><title>Clojure's Looping Syntax is Surprising</title><link>/posts/2019-5-30-clojures-looping-syntax/</link><pubDate>Thu, 30 May 2019 11:52:59 -0700</pubDate><guid>/posts/2019-5-30-clojures-looping-syntax/</guid><description>They aren&amp;rsquo;t super popular, but Clojure has a rich set of high level looping macros. You have for for list comprehensions, doseq for imperative looping over sequences, dotimes for an even simpler integer loop, while for raw predicate looping, and loop for any kind of arbitrary recursion-style looping you want to do. However, I&amp;rsquo;m not a huge fan of the exact syntax some of these macros use.
Let&amp;rsquo;s talk about let, which looks like this:</description></item><item><title>Codegen Loader</title><link>/posts/2019-05-28-codegen-loader/</link><pubDate>Tue, 28 May 2019 17:04:04 -0700</pubDate><guid>/posts/2019-05-28-codegen-loader/</guid><description>In what is very likely an enormously bad idea, I have built a JVM classloader that can load dynamically load Java source files into memory.
Why I&amp;rsquo;ve recently been going &amp;ldquo;Full Juxt&amp;rdquo;, using all of Juxt&amp;rsquo;s Clojure libraries, specifically juxt/aero for configuration, juxt/bidi for routing, juxt/yada for endpoint handling, weavejester/integrant for &amp;ldquo;building applications&amp;rdquo; (probably dependency injection), juxt/joplin for database migrations, and juxt/edge to tie it all together.
All of Juxt&amp;rsquo;s libraries are relentlessly data focused, and use deps.</description></item><item><title>Pipeline Operators</title><link>/posts/2018-11-3-pipeline-operators/</link><pubDate>Sat, 03 Nov 2018 19:28:01 -0700</pubDate><guid>/posts/2018-11-3-pipeline-operators/</guid><description>Pipeline &amp;ldquo;operators&amp;rdquo; or &amp;ldquo;threading&amp;rdquo;1 constructs are interesting language constructs. They are an acknowledgement that functional code can be a little obtuse. They reorient (or rewrite) functional code so it looks more like a &amp;ldquo;dataflow&amp;rdquo;. Particularly of Lisps, but also of some other functional languages, execution moves from the inside of expressions to the outside in a way that&amp;rsquo;s not particularly natural feeling. It&amp;rsquo;s a real source of the difficulty people express when reading functional code.</description></item><item><title>Operators</title><link>/posts/2018-08-15-operators/</link><pubDate>Wed, 15 Aug 2018 16:21:39 -0700</pubDate><guid>/posts/2018-08-15-operators/</guid><description>I recently started thinking about operators and math in programming languages. This is at least partly inspired by the programming language I&amp;rsquo;m making right now, but I&amp;rsquo;ll get to that later. It&amp;rsquo;s also inspired, in some sense, by the tutorials I was reading while trying to successfully parse my programming language. I didn&amp;rsquo;t find a tutorial specifically for what I was trying to do, which was fair, but I did find tutorials on parsing other more &amp;ldquo;normal&amp;rdquo; languages or more C-like languages, and it got me thinking.</description></item></channel></rss>