<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Pipeline Operators | Andrew Amis</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    <link rel="stylesheet" href="/css/syntax.css">

  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/">Home</a></li>
      
      <li><a href="/posts/">Posts</a></li>
      
      <li><a href="/games/">Games</a></li>
      
      <li><a href="/pictures/">Pictures</a></li>
      
      <li><a href="/downloads/resume.pdf">Resume</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h1><span class="title">Pipeline Operators</span></h1>

<h2 class="date">2018/11/03</h2>
</div>

<main>


<p>Pipeline &ldquo;operators&rdquo; or &ldquo;threading&rdquo;<sup class="footnote-ref" id="fnref:0"><a href="#fn:0">1</a></sup> constructs are interesting language
constructs. They are an acknowledgement that functional code can be a little
obtuse. They reorient (or rewrite) functional code so it looks more like a
&ldquo;dataflow&rdquo;. Particularly of Lisps, but also of some other functional languages,
execution moves from the inside of expressions to the outside in a way that&rsquo;s
not particularly natural feeling. It&rsquo;s a real source of the difficulty people
express when reading functional code.</p>

<h1 id="clojure">Clojure</h1>
<div class="highlight"><pre class="chroma"><code class="language-Clojure" data-lang="Clojure"><span class="p">(</span><span class="nb">reduce + </span><span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nb">+ </span><span class="nv">%</span> <span class="mi">5</span><span class="p">)</span> <span class="p">(</span><span class="nb">filter </span><span class="o">#</span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">rem </span><span class="nv">%</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">range </span><span class="mi">50</span><span class="p">))))</span></code></pre></div>
<p>So what does this do? It&rsquo;s a little hard to say. Allow me to introduce the
threaded macro:</p>
<div class="highlight"><pre class="chroma"><code class="language-Clojure" data-lang="Clojure"><span class="p">(</span><span class="nv">-&gt;&gt;</span>
    <span class="p">(</span><span class="nb">range </span><span class="mi">50</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">filter </span><span class="o">#</span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">rem </span><span class="nv">%</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">0</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nb">+ </span><span class="nv">%</span> <span class="mi">5</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">reduce </span><span class="nv">+</span><span class="p">))</span></code></pre></div>
<p>This is the &ldquo;thread-last&rdquo; macro, which inserts the last expression as the last
argument to the current statement. It&rsquo;s a macro, so this rewriting is done at
compile time. Clojure also has a &ldquo;thread-first&rdquo; macro, which puts the last
expression in the first argument, and most use of these macros is with these 2
macros. This is because the Clojure standard library is carefully written so
that, based on the data type you&rsquo;re dealing with, the operative argument is
always either the first or the last across multiple relevant functions.
<code>filter</code>, <code>map</code>, and <code>reduce</code> are all similar functions, and they all take the
data structure they operate as their last argument.</p>

<p>This can seem a little limiting. Mostly you can just trust the standard library
writers, and the public library authors, and your own code, to fit into this
model pretty well. If you&rsquo;re doing something a little strange, you can use the
<code>as-&gt;</code> macro to bind a value to a name, and then thread the expressions with the
name in the right argument location, rather than implicit placement of the <code>-&gt;</code>
macro. The ergonomics isn&rsquo;t as good because that name ends up littering your
pipeline expression, but it&rsquo;s entirely equivalent and quite useful.<sup class="footnote-ref" id="fnref:1"><a href="#fn:1">2</a></sup></p>

<p>By reorienting/rewriting the expression, you can easily read <em>from top to
bottom</em> the steps the expression takes to build the final value. Clojure also
allows for Java interop in the form of <code>(.methodName object args...)</code>. This fits
into the Clojure syntax nicely, and the threading macros let you chain method
calls more easily (although because it calls the method on the object that the
last method call returned, it can&rsquo;t be used to repeatedly call methods on the
same object unless that object is already a method chaining object, like a
Builder pattern object.)</p>

<p>Of course, one can <em>and should</em> question the value of these macros. As macros,
they are <em>new</em> syntax, but the nature of the macros and the <strong>aggressive</strong>
elision of the operant data<sup class="footnote-ref" id="fnref:4"><a href="#fn:4">3</a></sup> can really obscure what threaded code is
actually doing. I think it ultimately produces easier to read code, but it isn&rsquo;t
pure profit: it introduces the mental overhead of knowing at least something
about threaded macros.</p>

<p>Outside of understanding how these macros work, there isn&rsquo;t any extra syntax
because, as a Lisp, Clojure&rsquo;s syntax is so regular.<sup class="footnote-ref" id="fnref:2"><a href="#fn:2">4</a></sup></p>

<h1 id="elixir">Elixir</h1>

<p>Elixir doesn&rsquo;t have a threading macro, but it does have a pipeline operator.
It&rsquo;s still a macro, and still works in the same way, but looks a little
different. It solves the same problems, however.</p>
<div class="highlight"><pre class="chroma"><code class="language-Elixir" data-lang="Elixir"><span class="nc">Enum</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="nc">Enum</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="nc">Enum</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="mi">49</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">rem</span><span class="p">(</span><span class="ni">&amp;1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)),</span> <span class="o">&amp;</span><span class="p">(</span><span class="ni">&amp;1</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)),</span> <span class="o">&amp;+/</span><span class="mi">2</span><span class="p">)</span></code></pre></div>
<p>The <code>Enum</code> module always takes the collection as the first argument, and
additional parameters after, which makes the pipeline operator easier to use,
but makes this code exceptionally difficult to read. You read the names of the
operations first, then the initial collection, then a bunch of parenthesis,
operators, and commas that express several anonymous functions that get applied
according to the rules of the names you read before, but in reverse order. This
code makes heavy use of an anonymous function shorthand, and a piece of syntax
that is used to capture a named function as a value (<code>&amp;+/2</code> captures the 2-arity
<code>+</code> operator as a value so you can reduce with it) because it wouldn&rsquo;t fit on
one line otherwise, and indentation will not make this code clearer. Shortened by
the pipeline operator, this code gets a lot more readable.</p>
<div class="highlight"><pre class="chroma"><code class="language-Elixir" data-lang="Elixir"><span class="mi">0</span><span class="o">..</span><span class="mi">49</span>
<span class="o">|&gt;</span> <span class="nc">Enum</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">rem</span><span class="p">(</span><span class="ni">&amp;1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
<span class="o">|&gt;</span> <span class="nc">Enum</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="ni">&amp;1</span> <span class="o">+</span> <span class="mi">5</span><span class="p">))</span>
<span class="o">|&gt;</span> <span class="nc">Enum</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="o">&amp;+/</span><span class="mi">2</span><span class="p">)</span></code></pre></div>
<p>Although much more readable, for reference, this is what the code looks like
without the anonymous function shorthand.</p>
<div class="highlight"><pre class="chroma"><code class="language-Elixir" data-lang="Elixir"><span class="mi">0</span><span class="o">..</span><span class="mi">49</span>
<span class="o">|&gt;</span> <span class="nc">Enum</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">fn</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">rem</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="n">end</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nc">Enum</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">fn</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">5</span> <span class="n">end</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="nc">Enum</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="o">&amp;+/</span><span class="mi">2</span><span class="p">)</span></code></pre></div>
<p>Elixir is not object oriented and does not have methods, but almost all APIs
obey the rule that the first argument is the &ldquo;method receiver&rdquo;, so to speak.
This is adhered to almost to absurdity as seen in <code>Map.merge/2</code>, which takes 2
arguments, and merges the <em>second</em> map into the <em>first</em>, giving the <em>second</em>
map&rsquo;s keys precedence in the merged map. I think that <em>first</em> into <em>second</em>
would be a little more reasonable, but that&rsquo;s the decision they made.</p>

<p>In practice, Elixir code is mostly function calls like above, but not always.
Elixir also has structs, which are some sugar on top of maps, but which provide
attribute access with method-like calls, so <code>struct.field</code> would index into the
struct. Elixir also, of course, has binary operators, which break the usual rule
of function syntax and just exist as <code>operand + operand</code> in the code (see my
<a href="/posts/2018-08-15-operators/">article</a> for further discussion.)</p>

<p>How do these syntax aberrations fit into the pipeline operator? Very poorly. They
just don&rsquo;t at all, and the accepted method of, say, indexing into a struct is
with an anonymous function:</p>
<div class="highlight"><pre class="chroma"><code class="language-Elixir" data-lang="Elixir"><span class="n">id</span>
<span class="o">|&gt;</span> <span class="nc">Database</span><span class="o">.</span><span class="n">lookup</span><span class="p">()</span>
<span class="c1">#|&gt; &amp;(&amp;1.field).()</span>
<span class="o">|&gt;</span> <span class="n">fn</span> <span class="n">struct</span> <span class="o">-&gt;</span> <span class="n">struct</span><span class="o">.</span><span class="n">field</span> <span class="n">end</span><span class="o">.</span><span class="p">()</span>
<span class="o">|&gt;</span> <span class="nc">Enum</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">...</span><span class="p">)</span></code></pre></div>
<p>Even when using the shorthand (commented out in the above), this introduces
substantial line noise, and because function values can&rsquo;t be invoked normally,
they have to to be called with <code>function.()</code>, even more extraneous syntax is
required. Elixir, like Clojure, does have a shorthand for single arity functions
that let you elide the ending parentheses, <em>it doesn&rsquo;t work on anonymous
functions</em>, so any time you want to do anything other than just calling
functions that share first arguments, you introduce a bunch of extra syntax.</p>

<p>It&rsquo;s usually easier to use assignment pattern matching, which breaks you out of
the pipeline operator mode, which is kind of the whole point, but it also puts
the assignment matching <em>at the start of the pipeline expression</em>, while the
function that produces the value you&rsquo;re destructuring is all the way at the end.</p>

<h1 id="let"><code>let</code></h1>

<p>Sometimes threading macros and pipeline operators are just too much work, and
too much mental overhead. Luckily, we can just return to normal programming. I
don&rsquo;t see code that looks like this very much, but it&rsquo;s much more flexible:</p>
<div class="highlight"><pre class="chroma"><code class="language-Clojure" data-lang="Clojure"><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">coll</span> <span class="p">(</span><span class="nb">range </span><span class="mi">50</span><span class="p">)</span>
      <span class="nv">filtered</span> <span class="p">(</span><span class="nb">filter </span><span class="o">#</span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">rem </span><span class="nv">%</span> <span class="mi">2</span><span class="p">)</span> <span class="nv">coll</span><span class="p">)</span>
      <span class="nv">plus-five</span> <span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nb">+ </span><span class="nv">%</span> <span class="mi">5</span><span class="p">)</span> <span class="nv">filtered</span><span class="p">)</span>
      <span class="nv">sum</span> <span class="p">(</span><span class="nb">reduce + </span><span class="nv">plus-five</span><span class="p">)]</span>
    <span class="nv">sum</span><span class="p">)</span></code></pre></div>
<p><code>let</code> will let you reference any previous arbitrary step, let you rebind names,
and will let you destructure and match at any step. Elixir&rsquo;s variable
definitions let you do all of this too (Erlang disallows name rebinding, but
Elixir permits it.)<sup class="footnote-ref" id="fnref:5"><a href="#fn:5">5</a></sup></p>

<p>This does require you to name your intermediate steps which might be a
showstopper for some people, but if your code is that complex, names will help
whoever has to understand the code next.</p>

<p>It is worth noting that there are a couple of libraries in Elixir that do
<code>monadic</code> programming, in that they define a monadic type like <code>{:ok, value} |
{:error, message}</code> to indicate success or failure (like a <code>Result</code> type). This
is a known type, but there isn&rsquo;t huge support for it in the standard library,
and the pipeline operator can&rsquo;t deal with it. So, a collection of several
different libraries implementing monadic bind and pipeline operators, in
addition to some Haskell style <code>do</code> syntax for the full naming and destructuring
environment, have sprouted up, like <a href="https://hexdocs.pm/ok/OK.html">OK</a>. These are all similar but
slightly different, and there isn&rsquo;t a clear winner, so the whole thing is sort
of a mess. It&rsquo;s very useful to be able to pipeline failable operations together
while avoiding exceptions, but these libraries generally aren&rsquo;t substantially
easier to use with the above issues.</p>

<h1 id="rust">Rust</h1>

<p>Rust has all the extra syntax of Elixir with the addition of method calls.
Because it has method calls, you can build chaining APIs in Rust, which is sort
of the goal of this whole exercise. Just repeatedly call methods on whatever got
returned last to do what you want, and you always have normal assignments to
fall back on. Of course, someone did write a pipeline crate, and this is what it
looks like:</p>
<div class="highlight"><pre class="chroma"><code class="language-Rust" data-lang="Rust"><span class="c1">// takes a string length, doubles it and converts it back into a string
</span><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pipe</span><span class="o">!</span><span class="p">(</span><span class="w">
</span><span class="w">    </span><span class="s">&#34;abcd&#34;</span><span class="w">
</span><span class="w">    </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">len</span><span class="p">]</span><span class="w">
</span><span class="w">    </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">times</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">to_string</span><span class="p">]</span><span class="w">
</span><span class="w"></span><span class="p">);</span><span class="w">
</span><span class="w"></span></code></pre></div>
<p><sup class="footnote-ref" id="fnref:3"><a href="#fn:3">6</a></sup></p>

<p>The names in brackets are method calls on the value, <code>times(2)</code> is a function
that multiplies 2 values together, and <code>(as u32)</code> uses the <code>as</code> operator to
convert to an unsigned 32 bit integer. Because of diversity of syntax you can
use in Rust, to fully express the language in a pipelined fashion, you need a
lot of attendant syntax to make yourself clear.</p>

<p>You can use <code>pipeline.rs</code> in a monadic style, like in the following snippet:</p>
<div class="highlight"><pre class="chroma"><code class="language-Rust" data-lang="Rust"><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pipe_res</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;http://rust-lang.org&#34;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">download</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">parse</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">get_links</span><span class="p">)</span><span class="w">
</span><span class="w"></span></code></pre></div>
<p>This only calls the next pipe expression if the previous one returned
<code>Ok(value)</code> and not <code>Err(error)</code>, and calling the next pipe expression with the
value rather than the value in its monadic wrapper. This sort of monadic
programming is usually seen in rust through the <code>?</code> macro, which is used on
expressions which return <code>Result</code>s, and it expands to an expression that either
returns the wrapped value directly, or does returns from the function early with
the error value. It can&rsquo;t be used in functions which don&rsquo;t return <code>Result</code>s, but
it&rsquo;s a very idiomatic method of handling multiple failable operations in sequence.
You could write the above code using the <code>?</code> like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-Rust" data-lang="Rust"><span class="n">get_links</span><span class="p">(</span><span class="n">parse</span><span class="p">(</span><span class="n">download</span><span class="p">(</span><span class="s">&#34;http://rust-lang.org&#34;</span><span class="p">)</span><span class="o">?</span><span class="p">)</span><span class="o">?</span><span class="p">)</span><span class="o">?</span><span class="w">
</span><span class="w"></span></code></pre></div>
<p>Which doesn&rsquo;t really solve the readability problem, to be fair. However,
<code>Result</code> does have method chaining API which can be used like so:</p>
<div class="highlight"><pre class="chroma"><code class="language-Rust" data-lang="Rust"><span class="nb">Ok</span><span class="p">(</span><span class="s">&#34;http://rust-lang.org&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">.</span><span class="n">and_then</span><span class="p">(</span><span class="n">download</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">.</span><span class="n">and_then</span><span class="p">(</span><span class="n">parse</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">.</span><span class="n">and_then</span><span class="p">(</span><span class="n">get_links</span><span class="p">)</span><span class="w">
</span><span class="w"></span></code></pre></div>
<p><code>Result.and_then</code> applies a function to the value a <code>Result</code> wraps if and only if the
result is <code>Ok(value)</code>, and expects that function to return another <code>Result&lt;U, E&gt;</code>, but
<code>U</code> and <code>E</code> can be unrelated to the types of the original <code>Result</code>.</p>

<p>Ultimately, Rust is a distinctly imperative language that just doesn&rsquo;t suffer
from the same ordering-comprehension issues that Elixir and Clojure do. It has a
number of existing tools for managing control flow, but even if you want to use
a pipeline macro or similar, thanks to Rust&rsquo;s powerful ahead of time compiler,
you can be sure it won&rsquo;t have a runtime performance cost.</p>

<h1 id="haskell">Haskell</h1>

<p>I don&rsquo;t really know Haskell, but they generally solve this problem with
currying, which is a much broader and more powerful concept, but tends to be
opt-in in most languages, and usually not worth the effort or overhead to
&ldquo;opt-in&rdquo;. Haskell also has a much broader understanding and use of Monads, and
has an explicit <code>do</code> syntax in the language, which is used extensively for
similar purposes.</p>

<h1 id="conclusion">Conclusion</h1>

<p>Although confusing at first, threaded-style code can bring much needed clarity
to complex nested functional code. However, because it&rsquo;s a syntax
transformation, it works best in contexts with simple and straightforward
syntax where the syntax transformation is easy to implement and easy to
understand, like Clojure.</p>

<p>In more complicated syntactic contexts, like Elixir and Rust, it can be useful,
but the additional syntax can make it much harder to understand, and macros
quirks must either be learned or worked around.</p>

<p>Rust has enough extra moving pieces that it can accommodate not having a pipeline
operator, but Elixir doesn&rsquo;t, and might need more intricate macros to support
better ergonomics.</p>
<div class="footnotes">

<hr />

<ol>
<li id="fn:0"><p>I can see why they chose this name (you&rsquo;re threading the expressions
together, or you&rsquo;re threading the data through the expressions), but it
clashes with the threads used for parallelism so badly that it makes
researching this topic difficult. For reference, you can find the <a href="https://clojure.org/guides/threading_macros">Clojure
docs here</a> and the <a href="https://docs.racket-lang.org/threading/index.html">Racket docs here.</a></p>
 <a class="footnote-return" href="#fnref:0"><sup>[return]</sup></a></li>

<li id="fn:1"><p>Racket doesn&rsquo;t let you bind to names like <code>as-&gt;</code>, but in both first and
last threading macros, offers the opportunity to override the default
argument position behavior by inserting a <code>_</code> symbol in the code (like a
variable reference) to serve as the insertion point for the last expression.
Clojure will let you match/destructure with <code>as-&gt;</code>, and end up with several
different bound names, but the names get rebound <em>with every expression</em>, so
it&rsquo;s a little hard to imagine a situation where this wouldn&rsquo;t get very confusing.</p>
 <a class="footnote-return" href="#fnref:1"><sup>[return]</sup></a></li>

<li id="fn:4"><p>This is not helped by some functions producing transducers when called
with only 1 argument, like <code>(map #(+ % 5))</code> outside a thread macro is a
valid function call and produces a transducer. Transducers are composed like
functions with <code>comp</code>, so if you aren&rsquo;t entirely familiar with the threaded
macro, you might think you were looking at transducer code rather than
threaded code.</p>
 <a class="footnote-return" href="#fnref:4"><sup>[return]</sup></a></li>

<li id="fn:2"><p>It is worth noting that, in Clojure, you can &ldquo;call&rdquo; a keyword with a map as
  its argument, and index into a map, like so <code>(:key map)</code>, and that this works
  perfectly fine when used in a threaded macro, so <code>(-&gt; map :key)</code> is
  equivalent. This is part of a special feature of the threading macros that
  let you elide the parenthesis around 1-arity calls, so this is also
  equivalent to <code>(-&gt; map (:key))</code>.</p>
 <a class="footnote-return" href="#fnref:2"><sup>[return]</sup></a></li>

<li id="fn:5"><p>The Elixir version of the <code>let</code> example would be something like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-Elixir" data-lang="Elixir">  <span class="n">coll</span> <span class="o">=</span> <span class="mi">0</span><span class="o">..</span><span class="mi">49</span>
  <span class="n">filtered</span> <span class="o">=</span> <span class="nc">Enum</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">coll</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">rem</span><span class="p">(</span><span class="ni">&amp;1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
  <span class="n">plus_five</span> <span class="o">=</span> <span class="nc">Enum</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">filtered</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="ni">&amp;1</span> <span class="o">+</span> <span class="mi">5</span><span class="p">))</span>
  <span class="n">sum</span> <span class="o">=</span> <span class="nc">Enum</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">plus</span><span class="o">-</span><span class="n">five</span><span class="p">,</span> <span class="o">&amp;+/</span><span class="mi">2</span><span class="p">)</span></code></pre></div> <a class="footnote-return" href="#fnref:5"><sup>[return]</sup></a></li>
<li id="fn:3">From <a href="https://github.com/johannhof/pipeline.rs#examples">pipeline.rs</a>.
 <a class="footnote-return" href="#fnref:3"><sup>[return]</sup></a></li>
</ol>
</div>

</main>

  <footer>
  
  
  <hr/>
  &copy; <a href="http://atamis.me">Andrew Amis</a> &mdash; <a href="http://github.com/atamis">Github</a> &mdash; 2018
  
  </footer>
  </body>
</html>

